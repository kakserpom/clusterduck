#!/usr/bin/env node

(async () => {

    const ConfigFile = require("../misc/config")
    const ClusterDuck = require('../core/clusterduck')
    const daemonizeProcess = require('daemonize-process')
    const pidFileClass = require('../misc/pid-file')
    const md5 = require('md5')

    const {exec, spawn} = require('child_process')
    const {quote} = require('shell-quote')
    const path = require('path')
    const fs = require('fs')

    const Yargs = require('yargs')

    const InsertNode = require("../core/commands/insert-node")
    const DeleteNode = require("../core/commands/delete-node")

    const yargs = Yargs
        .option('daemonize', {
            alias: 'd',
            description: 'Daemonize',
            type: 'boolean',
        })
        .option('config-file', {
            alias: 'c',
            default: '/etc/clusterduck/clusterduck.yaml',
            description: 'Configuration file',
            type: 'string',
        });
    yargs.option('pid-file', {
        description: 'Pid-file',
        default: function () {
            const configFile = yargs.parse().configFile
            if (configFile === '/etc/clusterduck/clusterduck.yaml') {
                return '/var/run/clusterduck/clusterduck.pid'
            } else {
                return '/var/run/clusterduck/clusterduck-' + md5(configFile) + '.pid'
            }
        },
        type: 'string',
    })
        .strict()
        .option('experimental', {
            description: 'Allow using experimental modules',
            type: 'boolean',
            default: false
        })
        .option('verbose', {
            alias: 'v',
            description: 'Verbosity devel',
            type: 'string',
        })
        .option('log-dir', {
            type: 'string',
            default: '/var/log/clusterduck',
        })
    let argv = yargs.parse()

    try {
        process.on('SIGTERM', () => {
            process.emit('exit', 'SIGTERM')
            setTimeout(() => {
                process.exit()
            }, 200)
        })

        const clusterduck = new ClusterDuck(argv)

        yargs.command('gen-tls', 'generate TLS certificates', yargs => {
            const keyFile = path.dirname(argv.configFile) + '/clusterduck.key'
            const certFile = path.dirname(argv.configFile) + '/clusterduck.cert'

            const p = exec('openssl req -new -newkey rsa:4096 -days 365 -nodes -x509' +
                ' -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=clusterduck"' +
                ` -keyout ${quote([keyFile])} -out ${quote([certFile])}`, {stdio: 'inherit'})
            p.stderr.on('data', data => process.stdout.write(data))
        })

        yargs.command('stop', 'stop the server', yargs => {
        }, argv => {

            if (argv.verbose) console.info(`stop server`)
            const pid = new pidFileClass(argv.pidFile)
            try {
                pid.stop()
            } catch (err) {
                console.error(argv.verbose ? err : err.message)
            }
        })

        yargs.command('log [type]', 'show log', yargs => {
        }, argv => {
            const tail = spawn('tail', [
                '-f',
                '-n', 100,
                argv.logDir + '/' + (argv.type || 'debug') + '.log',
            ])
            tail.stdout.pipe(process.stdout)
        })


        InsertNode.cliCommand(yargs, clusterduck)
        DeleteNode.cliCommand(yargs, clusterduck)

        const jaysonRequest = (cmd, ...args) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const client = await clusterduck.jayson.client()
                    const {error, result} = await client.request(cmd, ...args)
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                } catch (err) {
                    console.error('Either clusterduck is not running or the jayson transport is not enabled')
                    console.error(argv.verbose ? err : err.message)
                }
            })
        }

        yargs.command({
            command: 'ls [paths..]',
            desc: 'List of entities',
            handler: async argv => {

                if (!argv.paths) {
                    return
                }

                const response = await jaysonRequest('ls', argv.paths)
                    .catch(error => console.error(argv.verbose ? error : error.message))

                const treeify = require('treeify')

                response.forEach(result => {
                    // console.log(result)
                    // process.stdout.write(treeify.asTree(result, true))

                    treeify.asLines(result, true, true, line => {
                        console.log(line)
                    })
                })
            }
        })

        argv = yargs
            .help()
            .alias('help', 'h')
            .parse()


        if (argv._.length > 0) {
            return
        }


        const pid = new pidFileClass(argv.pidFile)

        if (pid.running) {
            console.error('An instance is already running. Abort.')
            return
        }

        const debugStream = fs.createWriteStream(argv.logDir + '/debug.log', {flags: 'a'})
            , errorStream = fs.createWriteStream(argv.logDir + '/error.log', {flags: 'a'});

        process.stdout.writeReal = process.stdout.write
        process.stdout.write = data => {
            debugStream.write(data)
            process.stdout.writeReal(data)
        }

        process.stderr.writeReal = process.stderr.write
        process.stderr.write = data => {
            debugStream.write(data)
            errorStream.write(data)
            process.stderr.writeReal(data)
        }

        if (argv.daemonize) {

            if (argv.verbose) {
                console.log('[INFO] An instance has just started. PID: ' + process.pid)
            }
            daemonizeProcess()

        }

        pid.acquireOrThrow()

        clusterduck.set_config(new ConfigFile(argv.configFile))

        await clusterduck.run()
    } catch (err) {
        console.error(argv.verbose ? err : err.message)
        process.exit(1)
    }
})()
