#!/usr/bin/env node
(async function () {

    const ClusterDuck = require('../core/clusterduck')
    const Duckling = require('../core/duckling')
    const daemonizeProcess = require('daemonize-process')
    const pidFileClass = require('../misc/pid-file')
    const md5 = require('md5')
    const YAML = require('js-yaml')
    const {v4: uuidv4} = require('uuid')

    const Yargs = require('yargs')

    const InsertNode = require("../core/commands/insert-node")
    const DeleteNode = require("../core/commands/delete-node")

    let command;

    const yargs = Yargs
        .option('daemonize', {
            alias: 'd',
            description: 'Daemonize',
            type: 'boolean',
        })
        .option('config-file', {
            alias: 'c',
            default: '/etc/clusterduck.yaml',
            description: 'Configuration file',
            type: 'string',
        });
    yargs.option('pid-file', {
        description: 'Pid-file',
        default: function () {
            return '/var/run/clusterduck/clusterduck-' + md5(yargs.parse().configFile) + '.pid'
        },
        type: 'string',
    })
        .strict()
        .option('experimental', {
            description: 'Allow using experimental modules',
            type: 'boolean',
            default: false
        })
        .option('verbose', {
            alias: 'v',
            description: 'Verbosity devel',
            type: 'string',
        })
    const argv = yargs.parse()

    try {
        process.on('SIGTERM', () => process.emit('exit', 'SIGTERM'))

        const clusterduck = new ClusterDuck(argv)


        yargs
            .command('stop', 'stop the server', yargs => {
            }, (argv) => {
                clusterduck._command  = () => {
                    new Promise((resolve, reject) => {
                        if (argv.verbose) console.info(`stop server`)
                        const pid = new pidFileClass(argv.pidFile)
                        try {
                            pid.stop()
                        } catch (err) {
                            console.error(argv.verbose ? err : err.message)
                        }
                        resolve()
                    });
                };
            })


        InsertNode.cliCommand(yargs, clusterduck)
        DeleteNode.cliCommand(yargs, clusterduck)

        yargs.command('clusters', 'List of clusters', yargs => {
            clusterduck._command = () => {
                return new Promise(async (resolve, reject) => {
                    const client = await clusterduck.jayson.client()

                    const {error, result} = await client.request('clusters', [])
                    process.stdout.write(YAML.dump(result))
                })
            }
        });

        yargs
            .help()
            .alias('help', 'h')
            .parse()


        if (clusterduck._command) {
            await clusterduck._command()
        } else {
            if (argv.daemonize && !Duckling.isDuckling) {
                const pid = new pidFileClass(argv.pidFile);
                pid.acquireOrThrow()
                daemonizeProcess()
                if (argv.verbose) {
                    console.log('[INFO] An instance has just started. PID: ' + process.pid)
                }
            }
            if (Duckling.isDuckling) {
                clusterduck.runDuckling()
            } else {
                clusterduck.id = uuidv4()
                clusterduck.set_config(require('../misc/config')(argv.configFile))

                await clusterduck.run()
            }
        }
    } catch (err) {
        console.error(argv.verbose ? err : err.message)
        process.exit(1)
    }
})()
